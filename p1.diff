diff --git a/arch/x86/entry/syscalls/syscall_64.tbl b/arch/x86/entry/syscalls/syscall_64.tbl
index bbfc6d440870..986d835cb3d8 100644
--- a/arch/x86/entry/syscalls/syscall_64.tbl
+++ b/arch/x86/entry/syscalls/syscall_64.tbl
@@ -345,7 +345,9 @@
 334	common	rseq			__x64_sys_rseq
 424	common	pidfd_send_signal	__x64_sys_pidfd_send_signal
 434	common	pidfd_open		__x64_sys_pidfd_open
-
+435	common	get_log			__x64_sys_get_log
+436	common	set_log			__x64_sys_set_log
+437	common	log_message		__x64_sys_log_message
 #
 # x32-specific system call numbers start at 512 to avoid cache impact
 # for native 64-bit operation. The __x32_compat_sys stubs are created
diff --git a/include/linux/syscalls.h b/include/linux/syscalls.h
index 8e5b2c6d5dea..e29f0f690719 100644
--- a/include/linux/syscalls.h
+++ b/include/linux/syscalls.h
@@ -1296,5 +1296,11 @@ static inline unsigned int ksys_personality(unsigned int personality)
 
 	return old;
 }
+//could be long
+//could be char_user *message
+asmlinkage int sys_get_log(void);
+asmlinkage int sys_set_log(int new_level);
+asmlinkage int log_message(char *message, int level);
 
 #endif
+
diff --git a/kernel/sys.c b/kernel/sys.c
index 0a1cdee858de..f277f9deb331 100644
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@ -75,6 +75,7 @@
 
 #include "uid16.h"
 
+
 #ifndef SET_UNALIGN_CTL
 # define SET_UNALIGN_CTL(a, b)	(-EINVAL)
 #endif
@@ -2807,3 +2808,58 @@ COMPAT_SYSCALL_DEFINE1(sysinfo, struct compat_sysinfo __user *, info)
 	return 0;
 }
 #endif /* CONFIG_COMPAT */
+
+int log_level = 0;
+EXPORT_SYMBOL(log_level);
+
+SYSCALL_DEFINE0(get_log)
+{
+	if(log_level < 0 || log_level > 7){
+		return -1;
+	}
+
+	return log_level;
+}
+
+SYSCALL_DEFINE1(set_log ,int, new_level)
+{
+
+	 kuid_t taskRootUid;
+        taskRootUid.val = 0;
+
+	if(new_level < 0 || new_level > 7){
+		return -1;
+	}
+
+	if(get_current_cred() == NULL){
+		return -1;
+	}
+	else if(!uid_eq(get_current_cred()->uid,taskRootUid)){
+		return -1;
+	}
+	else {
+	log_level = new_level;
+	}
+	return log_level;
+
+}
+
+SYSCALL_DEFINE2(log_message, char*, message, int, level){
+	if(level < 0 || level > 7){
+		return -1;
+	}
+	else if (log_level < level){
+		return level;
+	}
+	else {
+		if(level == 0) printk(KERN_EMERG "KERN_EMERG [%s, %d]: %s\n",current->comm, current->pid, message);
+		else if(level == 1) printk(KERN_ALERT "KERN_ALERT [%s, %d]: %s\n", current->comm, current->pid, message);
+		else if(level == 2) printk(KERN_CRIT "KERN_CRIT [%s, %d]: %s\n", current->comm, current->pid, message);
+		else if(level == 3) printk(KERN_ERR "KERN_ERR [%s, %d]: %s\n", current->comm, current->pid, message);
+		else if(level == 4) printk(KERN_WARNING "KERN_WARNING [%s, %d]: %s\n", current->comm, current->pid, message);
+		else if(level == 5) printk(KERN_NOTICE "KERN_NOTICE [%s, %d]: %s\n", current->comm, current->pid, message);
+		else if(level == 6) printk(KERN_INFO "KERN_INFO [%s, %d]: %s\n", current->comm, current->pid, message);
+		else if(level ==7) printk(KERN_DEBUG "KERN_DEBUG [%s, %d]: %s\n", current->comm, current->pid, message);
+		return level;
+	}
+}
